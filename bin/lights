#!/usr/bin/env ruby

require 'rubyhue'
require 'optparse'

HUE_CONFIG_PATH = "#{ENV["HOME"]}/.hueconfig"

class HueCli

  attr_reader :username, :ip
  def initialize
    if File.exists? HUE_CONFIG_PATH
      saved_data = JSON.parse( IO.read( HUE_CONFIG_PATH ) )
      @username = saved_data["username"]
      @ip = saved_data["bridge_ip"]
    end
  end
  
  def config
    options = {}
    OptionParser.new do |opts|
      opts.on("-u", "--user <username>", String, "Username") do |url|
        options[:user] = url
      end
      opts.on("-i", "--ip <bridge ip>", String, "Bridge ip address") do |ip|
        options[:ip] = ip
      end
      opts.on("-f", "--force", "Force write to config file") do |f|
        options[:force] = f
      end
      opts.on("-l", "--list", "List saved configuration settings") do |l|
        options[:list] = l
      end
    end.parse!
   
    if !options[:user] && !options[:ip] && !options[:list]
      puts "Must specify username and/or bridge IP: --user <username> --ip <IP addr. of bridge>"
      exit 1
    end
 
    if options[:list]
      puts "Bridge IP: #{@ip}"
      puts "Username:  #{@username}"
    else
      if !options[:force] && File.exists?(HUE_CONFIG_PATH)
        overwrite = ""
        while overwrite[0] != "y" \
                && overwrite[0] != "Y" \
                && overwrite[0] != "n" \
                && overwrite[0] != "N" \
                && overwrite[0] != "\n"
          print "Hue config already exists. Overwrite? [Y/n]: "
          overwrite = STDIN.gets
        end
        overwrite.upcase!
        if overwrite[0] == "N"
          exit
        end
      end
  
      config = {
        "username" => options[:user] || @username,
        "bridge_ip" => options[:ip] || @ip
      }
      File.open(HUE_CONFIG_PATH,"w+") { |file| file.write(config.to_json) }
      puts "Configuration settings saved."
    end
  end
  
  def list
    hue = Hue.new @ip, @username 
    bulbs_response = hue.request_bulb_list
    bulbs_response.each do |id,value|
      info = hue.request_bulb_info( id )
      puts "[#{id}] #{info["name"]}"
    end
  end
  
  def register
    hue = Hue.new @ip, @username
    response = hue.register_username
  end

  def discover 
    options = {}
    OptionParser.new do |opts|
      opts.on("-s", "--save", "Save discovered bridge to configuration file") do |s|
        options[:save] = s
      end
    end.parse!

    hue = Hue.new @ip, @username
    bridges = hue.discover_hubs
    bridges.each { |b| puts "#{b["name"]}: #{b["internalipaddress"]}" }

    if options[:save] && bridges.length >= 1
      config = {
        "username" => @username,
        "bridge_ip" => bridges.first["internalipaddress"]
      }
      File.open(HUE_CONFIG_PATH,"w+") { |file| file.write(config.to_json) }
      puts "Discovered bridge IP saved."
    end
  end

  def on
    on_off true
  end

  def off
    on_off false
  end

  def set
    options = {}
    OptionParser.new do |opts|
      opts.on("-o", "--on", "Turn lights on") do |o|
        options[:on] = o
      end
      opts.on("-f", "--off", "Turn lights off") do |f|
        options[:off] = f
      end
      opts.on("-l", "--lights 1,2,...N", Array, "Which lights to control") do |l|
        options[:lights] = l
      end
    end.parse!

    bad_args = false
    if !options[:on] && !options[:off]
      puts "Must specify a state to set."
      bad_args = true
    end
    if !options[:lights]
      puts "Must specify which lights to control."
      bad_args = true
    end
    exit 1 if bad_args    
    
    if options[:on]
      set_on(true,options[:lights])
    elsif options[:off]
      set_on(false,options[:lights])
    end 
  end

private
  def on_off(is_on)
    options = {}
    OptionParser.new do |opts|
      opts.on("-l", "--lights 1,2,...N", Array, "Which lights to control") do |l|
        options[:lights] = l 
      end
    end.parse!

    if !options[:lights]
      puts "Must specify which lights to control."
      exit 1
    end

   set_on is_on, options[:lights]
  end

  def set_on(is_on, lights)
    on_state = { "on" => is_on }
    state = HueBulbState.new(on_state)

    hue = Hue.new @ip, @username
    if lights.first == "all"
      hue.set_group_state 0,state
    else
      lights.each { |l| hue.set_bulb_state(l,state) }
    end
  end
end

  
if !ARGV[0]
  STDERR.puts "Must specify a command. (config, list, register, discover, on, off, set)"
  exit 1
end

begin
  cli = HueCli.new
  command = ARGV.shift
  if command == "config"
    cli.config
  elsif command == "discover"
    cli.discover
  elsif !cli.username || !cli.ip
    puts "Please run 'lights config' before using."
  elsif command == "list"
    cli.list
  elsif command == "register"
    cli.register
  elsif command == "on"
    cli.on
  elsif command == "off"
    cli.off
  elsif command == "set"
    cli.set
  else
    puts "Cannot find command #{command}."
  end
rescue HueBridgeConnectException,
        HueUsernameException => e
  puts e.message
rescue Errno::ENETUNREACH, Errno::ENETDOWN
  puts "Please check your internet connection and try again."
end


