#!/usr/bin/env ruby

require 'lights'
require 'optparse'

LIGHTS_CONFIG_PATH = "#{ENV["HOME"]}/.lightsconfig"

class LightsCli

  def initialize
    @config = {}
    if File.exists? LIGHTS_CONFIG_PATH
      @config = JSON.parse( IO.read( LIGHTS_CONFIG_PATH ) )
    end
  end

  def configured?
    @config["username"] && @config["bridge_ip"]
  end
  
  def config
    options = {}
    OptionParser.new do |opts|
      opts.on("-u", "--user <username>", String, "Username") do |url|
        options[:user] = url
      end
      opts.on("-i", "--ip <bridge ip>", String, "Bridge ip address") do |ip|
        options[:ip] = ip
      end
      opts.on("-f", "--force", "Force write to config file") do |f|
        options[:force] = f
      end
      opts.on("-l", "--list", "List saved configuration settings") do |l|
        options[:list] = l
      end
    end.parse!
 
    if !options[:user] && !options[:ip] && !options[:list]
      puts "Must specify username and/or bridge IP: --user <username> --ip <IP addr. of bridge>"
      exit 1
    end
 
    if options[:list]
      @config.each { |k,v| puts "#{k}: #{v}" }
    else
      if !options[:force] && File.exists?(LIGHTS_CONFIG_PATH)
        overwrite = ""
        while overwrite[0] != "y" \
                && overwrite[0] != "Y" \
                && overwrite[0] != "n" \
                && overwrite[0] != "N" \
                && overwrite[0] != "\n"
          print "Lights config already exists. Overwrite? [Y/n]: "
          overwrite = STDIN.gets
        end
        overwrite.upcase!
        if overwrite[0] == "N"
          exit
        end
      end
  
      @config["username"] = options[:user] || @config["username"]
      @config["bridge_ip"] = options[:ip] || @config["bridge_ip"]
  
      write_config
      puts "Configuration settings saved."
    end
  end
  
  def list
    lights = Lights.new @config["bridge_ip"], @config["username"]
    if !ARGV[0] || ARGV[0] == "lights"
      bulbs_response = lights.request_bulb_list
      bulbs_response.each do |id,value|
        bulb = lights.request_bulb_info( id )
        puts "[#{id}] #{bulb.name}"
      end
    elsif ARGV[0] == "sensors"
      sensors_response = lights.request_sensor_list
      sensors_response.each do |id,value|
        sensor = lights.request_sensor_info( id )
        puts "[#{id}] #{sensor.name}"
      end
    elsif ARGV[0] == "groups"
      groups_response = lights.request_group_list
      groups = []
      groups_response.each do |id,value|
        groups << lights.request_group_info( id )
      end

      c1w = groups.collect{|g|g.id.to_s}.group_by(&:size).max.first + 2
      c2w = groups.collect{|g|g.name.to_s}.group_by(&:size).max.first + 2
      c3w = groups.collect{|g|g.lights.to_s}.group_by(&:size).max.first + 2

      puts "ID".ljust(c1w) + "NAME".ljust(c2w) + "LIGHTS".ljust(c3w)
      puts "=" * (c1w+c2w+c3w+6)
      groups.each do |g| 
        puts g.id.ljust(c1w) + g.name.ljust(c2w) + g.lights.join(',').ljust(c3w)
      end
    elsif ARGV[0] == "scenes"
      scenes_response = lights.request_scene_list
      scenes = []
      scenes_response.each do |id,value| 
        scenes << Scene.new(id,value)
      end

      c1w = scenes.collect{|s|s.id.to_s}.group_by(&:size).max.first + 2
      c2w = scenes.collect{|s|s.name.to_s}.group_by(&:size).max.first + 2
      c3w = scenes.collect{|s|s.lights.to_s}.group_by(&:size).max.first + 2

      puts "ID".ljust(c1w) + "NAME".ljust(c2w) + "LIGHTS".ljust(c3w)
      puts "=" * (c1w+c2w+c3w+6)
      scenes.each do |s| 
        puts s.id.ljust(c1w) + s.name.ljust(c2w) + s.lights.join(',').ljust(c3w)
      end
    end
  end
  
  def register
    lights = Lights.new @config["bridge_ip"], @config["username"]
    response = lights.register_username
  end

  def discover 
    options = {}
    OptionParser.new do |opts|
      opts.on("-s", "--save", "Save discovered bridge to configuration file") do |s|
        options[:save] = s
      end
    end.parse!

    lights = Lights.new @config["bridge_ip"], @config["username"]
    bridges = lights.discover_hubs
    bridges.each_with_index { |b,i| puts "[#{i+1}] #{b.name}: #{b.ip}" }

    if options[:save] && bridges.length >= 1
      if bridges.length > 1
        which_bridge = -1
        while !(which_bridge >=0 && which_bridge <= bridges.length)
          print "Which bridge would you like to save? (0 for none): "
          which_bridge = Integer( gets ) rescue -1 
        end
      else
        which_bridge = 1
      end
      if which_bridge != 0
        @config["bridge_ip"] = bridges[which_bridge.to_i-1].ip
        write_config
        puts "Discovered bridge IP saved: #{bridges[which_bridge-1].ip}"
      end
    elsif bridges.length == 0
      puts "Did not discover any bridges."
    end
  end

  def on
    on_off true
  end

  def off
    on_off false
  end

  def set
    options = {}
    OptionParser.new do |opts|
      opts.on("-o", "--on", "Turn lights on") do |o|
        options[:on] = o
      end
      opts.on("-f", "--off", "Turn lights off") do |f|
        options[:off] = f
      end
      opts.on("-c", "--ct color_temp", OptionParser::DecimalInteger, "Set color temperature") do |c|
        options[:ct] = c
      end
      opts.on("-b", "--brightness brightness", OptionParser::DecimalInteger, "Set brightness") do |b|
        options[:brightness] = b
      end
      opts.on("-s", "--saturation saturation", OptionParser::DecimalInteger, "Set saturation") do |s|
        options[:saturation] = s
      end
      opts.on("-h", "--hue hue", OptionParser::DecimalInteger, "Set hue") do |h|
        options[:hue] = h
      end
      opts.on("-e", "--effect none|colorloop", String, "Set effect") do |e|
        options[:effect] = e
      end
      opts.on("-a", "--alert none|select|lselect", String, "Set alert") do |a|
        options[:alert] = a
      end
      opts.on("-z", "--xy x,y", Array, "Set xy") do |z|
        options[:xy] = z
      end
      opts.on("-l", "--lights 1,2,...N", Array, "Which lights to control") do |l|
        options[:lights] = l
      end
      opts.on("-d", "--duration seconds", OptionParser::DecimalInteger, "Transition duration in seconds") do |d|
        options[:duration] = d
      end
    end.parse!

    bad_args = false
    if !options[:on] && !options[:off] \
        && !options[:ct] && !options[:brightness] \
        && !options[:hue] && !options[:saturation] \
        && !options[:effect] && !options[:alert] \
        && !options[:xy]
      puts "Must specify a state to set."
      bad_args = true
    end
    if !options[:lights]
      puts "Must specify which lights to control."
      bad_args = true
    end
    if (options[:hue] || options[:saturation]) \
        && options[:ct]
      puts "Cannot set both color temperature and hue/saturation."
      bad_args = true
    end
    exit 1 if bad_args    
   
    s = BulbState.new 
    if options[:on]
      s.on = true
    elsif options[:off]
      s.on = false
    end
    if options[:ct]
      s.ct = options[:ct]
    end 
    if options[:brightness]
      s.bri = options[:brightness]
    end
    if options[:saturation]
      s.sat = options[:saturation]
    end
    if options[:hue]
      s.hue = options[:hue]
    end
    if options[:effect]
      s.effect = options[:effect]
    end
    if options[:duration]
      s.transition_time = options[:duration] * 10
    end
    if options[:alert]
      s.alert = options[:alert]
    end
    if options[:xy]
      s.xy = options[:xy]
    end
    set_state(s,options[:lights])
    
  end

private
  def set_state(state,bulbs)
    lights = Lights.new @config["bridge_ip"], @config["username"]
    if bulbs.first == "all"
      lights.set_group_state 0,state
    else
      bulbs.each { |l| lights.set_bulb_state(l,state) }
    end 
  end

  def write_config
    File.open(LIGHTS_CONFIG_PATH,"w+") { |file| file.write(@config.to_json) }
  end

  def on_off(is_on)
    options = {}
    OptionParser.new do |opts|
      opts.on("-l", "--lights 1,2,...N", Array, "Which lights to control") do |l|
        options[:lights] = l 
      end
    end.parse!

    if !options[:lights]
      puts "Must specify which lights to control."
      exit 1
    end

    s = BulbState.new
    s.on = is_on
    set_state s, options[:lights]
  end
end

  
if !ARGV[0]
  STDERR.puts "Must specify a command. (config, list, register, discover, on, off, set)"
  exit 1
end

begin
  cli = LightsCli.new
  command = ARGV.shift
  if command == "config"
    cli.config
  elsif command == "discover"
    cli.discover
  elsif !cli.configured?
    puts "Please run 'lights config' before using."
  elsif command == "list"
    cli.list
  elsif command == "register"
    cli.register
  elsif command == "on"
    cli.on
  elsif command == "off"
    cli.off
  elsif command == "set"
    cli.set
  else
    puts "Cannot find command #{command}."
  end
rescue BridgeConnectException,
        UsernameException,
        BulbStateValueOutOfRangeException,
        BulbStateValueTypeException => e
  puts e.message
rescue Errno::ENETUNREACH, Errno::ENETDOWN
  puts "Please check your internet connection and try again."
rescue Interrupt
  puts ""
end


