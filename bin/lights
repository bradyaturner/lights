#!/usr/bin/env ruby

require 'lights'
require 'optparse'
require 'simpletable'

LIGHTS_CONFIG_PATH = "#{ENV["HOME"]}/.lightsconfig"

class LightsCli

  def initialize
    @config = {}
    if File.exists? LIGHTS_CONFIG_PATH
      @config = JSON.parse( IO.read( LIGHTS_CONFIG_PATH ) )
    end
  end

  def configured?
    @config["username"] && @config["bridge_ip"]
  end
  
  def config
    options = {}
    OptionParser.new do |opts|
      opts.on("-u", "--user <username>", String, "Username") do |url|
        options[:user] = url
      end
      opts.on("-i", "--ip <bridge ip>", String, "Bridge ip address") do |ip|
        options[:ip] = ip
      end
      opts.on("-f", "--force", "Force write to config file") do |f|
        options[:force] = f
      end
      opts.on("-l", "--list", "List saved configuration settings") do |l|
        options[:list] = l
      end
    end.parse!
 
    if !options[:user] && !options[:ip] && !options[:list]
      puts "Must specify username and/or bridge IP: --user <username> --ip <IP addr. of bridge>"
      exit 1
    end
 
    if options[:list]
      @config.each { |k,v| puts "#{k}: #{v}" }
    else
      if !options[:force] && File.exists?(LIGHTS_CONFIG_PATH)
        overwrite = ""
        while overwrite[0] != "y" \
                && overwrite[0] != "Y" \
                && overwrite[0] != "n" \
                && overwrite[0] != "N" \
                && overwrite[0] != "\n"
          print "Lights config already exists. Overwrite? [Y/n]: "
          overwrite = STDIN.gets
        end
        overwrite.upcase!
        if overwrite[0] == "N"
          exit
        end
      end
  
      @config["username"] = options[:user] || @config["username"]
      @config["bridge_ip"] = options[:ip] || @config["bridge_ip"]
  
      write_config
      puts "Configuration settings saved."
    end
  end
 
  def create
    type = ARGV.shift
    hue = Lights.new @config["bridge_ip"], @config["username"]
    options = {}    

    case type
    when "group"
      OptionParser.new do |opts|
        opts.on("-l", "--lights 1,2,...N", Array, "Which lights to put in group") do |l|
          options[:lights] = l
        end
        opts.on("-n", "--name <name>", String, "Set group name") do |n|
          options[:name] = n
        end
      end.parse!
      
      if !options[:lights]
        puts "Must specify which lights to group."
        exit 1
      end
      if !options[:name]
        puts "Must specify group name."
        exit 1
      end

      group = Group.new
      group.name = options[:name]
      group.lights = options[:lights] 
      hue.create_group(group)   
    when nil
      STDERR.puts "Must specify a type to create."
    else
      STDERR.puts "Don't know how to create type \"#{type}\"."
    end
  end

  def delete
    type = ARGV.shift
    hue = Lights.new @config["bridge_ip"], @config["username"]
    options = {}

    case type
    when "group"
      id = ARGV.shift

      if !id
        puts "Must specify group id."
        exit 1
      end

      hue.delete_group id
    when "user"
      id = ARGV.shift

      if !id
        puts "Must specify user id."
        exit 1
      end

      hue.delete_user id
    when nil
      STDERR.puts "Must specify a type to delete."
    else
      STDERR.puts "Don't know how to delete type \"#{type}\"."
    end
  end
 
  def list
    hue = Lights.new @config["bridge_ip"], @config["username"]
    objects = []
    titles = []
    methods = []

    options = {}
    OptionParser.new do |opts|
      opts.on("-j", "--json", "Print JSON response") do |j|
        options[:json] = j
      end
    end.parse!

    type = ARGV.shift
    case type
    when nil, "","lights"
      response = hue.request_bulb_list
      response.each{|id,value| objects << hue.request_bulb_info( id )}
      titles = ["ID","NAME"]
      methods = [:id,:name]
    when "sensors"
      response = hue.request_sensor_list
      response.each { |id,value| objects << hue.request_sensor_info( id )}
      titles = ["ID","NAME"]
      methods = [:id,:name]
    when "groups"
      response = hue.request_group_list
      response.each {|id,value| objects << hue.request_group_info( id )}
      titles = ["ID","NAME","LIGHTS"]
      methods = [:id,:name,:lights]
    when "scenes"
      response = hue.request_scene_list
      response.each {|id,value| objects << Scene.new(id,value)}
      titles = ["ID","NAME","LIGHTS"]
      methods = [:id,:name,:lights]
    when "users"
      response = hue.request_config
      response["whitelist"].each {|id,value| objects << User.new(id,value)}
      titles = ["ID","NAME","CREATE DATE","LAST USE DATE"]
      methods = [:id,:name,:create_date,:last_use_date]
    when "rules"
      response = hue.request_rules
      response.each {|id,value| objects << Rule.new(id,value)}
      titles = ["ID","NAME"]
      methods = [:id,:name]
    when "datastore"
      response = hue.request_datastore
      response["lights"].each {|id,value| objects << Bulb.new(id,value)}
      response["groups"].each {|id,value| objects << Group.new(id,value)}
      response["config"]["whitelist"].each {|id,value| objects << User.new(id,value)}
      response["rules"].each {|id,value| objects << Rule.new(id,value)}
      response["scenes"].each {|id,value| objects << Scene.new(id,value)}
      response["schedules"].each {|id,value| objects << Bulb.new(id,value)}
      titles = ["TYPE","ID","NAME"]
      methods = [:class,:id,:name]
    else
      puts "Don't know how to list \"#{type}\""
      return
    end
    if options[:json]
      jp response
    else
      SimpleTable.new.from_objects(objects,titles,methods).print_text
    end
  end
  
  def register
    lights = Lights.new @config["bridge_ip"], @config["username"]
    response = lights.register_username
  end

  def discover 
    options = {}
    OptionParser.new do |opts|
      opts.on("-s", "--save", "Save discovered bridge to configuration file") do |s|
        options[:save] = s
      end
    end.parse!

    lights = Lights.new @config["bridge_ip"], @config["username"]
    bridges = lights.discover_hubs
    bridges.each_with_index { |b,i| puts "[#{i+1}] #{b.name}: #{b.ip}" }

    if options[:save] && bridges.length >= 1
      if bridges.length > 1
        which_bridge = -1
        while !(which_bridge >=0 && which_bridge <= bridges.length)
          print "Which bridge would you like to save? (0 for none): "
          which_bridge = Integer( gets ) rescue -1 
        end
      else
        which_bridge = 1
      end
      if which_bridge != 0
        @config["bridge_ip"] = bridges[which_bridge.to_i-1].ip
        write_config
        puts "Discovered bridge IP saved: #{bridges[which_bridge-1].ip}"
      end
    elsif bridges.length == 0
      puts "Did not discover any bridges."
    end
  end

  def on
    on_off true
  end

  def off
    on_off false
  end

  def set
    options = {}
    OptionParser.new do |opts|
      opts.on("-o", "--on", "Turn lights on") do |o|
        options[:on] = o
      end
      opts.on("-f", "--off", "Turn lights off") do |f|
        options[:off] = f
      end
      opts.on("-c", "--ct color_temp", OptionParser::DecimalInteger, "Set color temperature") do |c|
        options[:ct] = c
      end
      opts.on("-b", "--brightness brightness", OptionParser::DecimalInteger, "Set brightness") do |b|
        options[:brightness] = b
      end
      opts.on("-s", "--saturation saturation", OptionParser::DecimalInteger, "Set saturation") do |s|
        options[:saturation] = s
      end
      opts.on("-h", "--hue hue", OptionParser::DecimalInteger, "Set hue") do |h|
        options[:hue] = h
      end
      opts.on("-e", "--effect none|colorloop", String, "Set effect") do |e|
        options[:effect] = e
      end
      opts.on("-a", "--alert none|select|lselect", String, "Set alert") do |a|
        options[:alert] = a
      end
      opts.on("-z", "--xy x,y", Array, "Set xy") do |z|
        options[:xy] = z
      end
      opts.on("-l", "--lights 1,2,...N", Array, "Which lights to control") do |l|
        options[:lights] = l
      end
      opts.on("-g", "--groups 1,2,...N", Array, "Which groups to control") do |g|
        options[:groups] = g
      end
      opts.on("-d", "--duration seconds", OptionParser::DecimalInteger, "Transition duration in seconds") do |d|
        options[:duration] = d
      end
    end.parse!

    bad_args = false
    if !options[:on] && !options[:off] \
        && !options[:ct] && !options[:brightness] \
        && !options[:hue] && !options[:saturation] \
        && !options[:effect] && !options[:alert] \
        && !options[:xy]
      puts "Must specify a state to set."
      bad_args = true
    end
    if !options[:lights] && !options[:groups]
      puts "Must specify which lights/groups to control."
      bad_args = true
    end
    if (options[:hue] || options[:saturation]) \
        && options[:ct]
      puts "Cannot set both color temperature and hue/saturation."
      bad_args = true
    end
    exit 1 if bad_args    
   
    s = BulbState.new 
    if options[:on]
      s.on = true
    elsif options[:off]
      s.on = false
    end
    if options[:ct]
      s.ct = options[:ct]
    end 
    if options[:brightness]
      s.bri = options[:brightness]
    end
    if options[:saturation]
      s.sat = options[:saturation]
    end
    if options[:hue]
      s.hue = options[:hue]
    end
    if options[:effect]
      s.effect = options[:effect]
    end
    if options[:duration]
      s.transition_time = options[:duration] * 10
    end
    if options[:alert]
      s.alert = options[:alert]
    end
    if options[:xy]
      s.xy = options[:xy]
    end

    if options[:lights]
    set_bulb_state(s,options[:lights])
    elsif options[:groups]
      set_group_state(s,options[:groups])
    end
  end

private
  def set_bulb_state(state,bulbs)
    lights = Lights.new @config["bridge_ip"], @config["username"]
    if bulbs.first == "all"
      lights.set_group_state 0,state
    else
      bulbs.each { |l| lights.set_bulb_state(l,state) }
    end 
  end
  
  def set_group_state(state,groups)
    hue = Lights.new @config["bridge_ip"], @config["username"]
    groups.each { |g| hue.set_group_state(g,state) }
  end

  def write_config
    File.open(LIGHTS_CONFIG_PATH,"w+") { |file| file.write(@config.to_json) }
  end

  def on_off(is_on)
    options = {}
    OptionParser.new do |opts|
      opts.on("-l", "--lights 1,2,...N", Array, "Which lights to control") do |l|
        options[:lights] = l 
      end
    end.parse!

    if !options[:lights]
      puts "Must specify which lights to control."
      exit 1
    end

    s = BulbState.new
    s.on = is_on
    set_bulb_state s, options[:lights]
  end
end

  
if !ARGV[0]
  STDERR.puts "Must specify a command. (config, list, register, discover, on, off, set, create, delete)"
  exit 1
end

begin
  cli = LightsCli.new
  command = ARGV.shift
  if command == "config"
    cli.config
  elsif command == "discover"
    cli.discover
  elsif !cli.configured?
    puts "Please run 'lights config' before using."
  elsif command == "list"
    cli.list
  elsif command == "register"
    cli.register
  elsif command == "on"
    cli.on
  elsif command == "off"
    cli.off
  elsif command == "set"
    cli.set
  elsif command == "create"
    cli.create
  elsif command == "delete"
    cli.delete
  else
    puts "Cannot find command #{command}."
  end
rescue BridgeConnectException,
        UsernameException,
        BulbStateValueOutOfRangeException,
        BulbStateValueTypeException => e
  puts e.message
rescue Errno::ENETUNREACH, Errno::ENETDOWN
  puts "Please check your internet connection and try again."
rescue Interrupt
  puts ""
end


